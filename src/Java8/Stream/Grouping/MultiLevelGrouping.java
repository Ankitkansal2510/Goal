package Java8.Stream.Grouping;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import static java.util.stream.Collectors.groupingBy;
/**
 * In the previous grouping example we have shown to group Transaction either by Currency or by Risk
 *
 * Now suppose if we want to combine both grouping into one.
 *
 * This also we can do
 *
 * We can acheive multilevel grouping by using a Collector created with a two argument version of the Collectors.groupingBy()
 * factory method which accepts the second type argument collector beside the usual classification.
 *
 * So to perform two level grouping we can pass inner groupingBy to outer GroupingBy
 * **/
public class MultiLevelGrouping {

    public static void main(String[] args) {
        List<Transaction> list=new ArrayList<>();
        list.add(new Transaction("INR",550));
        list.add(new Transaction("JPY",1000));
        list.add(new Transaction("US",200));
        list.add(new Transaction("POUND",550));
        list.add(new Transaction("US",1000));
        list.add(new Transaction("INR",200));
        list.add(new Transaction("CHZ",1700));
        list.add(new Transaction("INR",1500));

        Map<String,Map<Risk,List<Transaction>>> result=
                list.stream().collect(groupingBy(Transaction::getCurrency,
                        groupingBy(d->{
                            if(d.getAmount()<500) return Risk.LOWER;
                            else if (d.getAmount()>500 && d.getAmount()<1000) return Risk.MEDIUM;
                            else return Risk.HIGH;
                        })));
        /**
         *Here the Outer map has a key the values generated by the first level classification i.e JPY,CHZ,INR,US
         * the value of this key is another map having key as value generated by the inner level of grouping i.e RISK
         *
         *
         */

        result.forEach((k,v)-> System.out.println(k + " " +v));


        Map<String,Map<Risk,Map<Integer,List<Transaction>>>> multiLevelGrouping=
                list.stream().collect(groupingBy(Transaction::getCurrency,
                        groupingBy(d->{
                            if(d.getAmount()>500 && d.getAmount()<1000) return Risk.MEDIUM;
                            else if(d.getAmount()<500) return Risk.LOWER;
                            else return Risk.MEDIUM;
                        },groupingBy(Transaction::getAmount))));
        System.out.println("Three level of multilevel grouping");
        multiLevelGrouping.forEach((k,v)-> System.out.println(k+ "   " +v));



    }
}
